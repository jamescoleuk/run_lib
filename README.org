#+TITLE:  ~run_lib~, a command runner alternative to ~make~
#+DATE:    February 23, 2020
#+STARTUP: inlineimages nofold

* Table of Contents :TOC_3:noexport:
- [[#description][Description]]
- [[#features][Features]]
- [[#installation][Installation]]
- [[#configuration][Configuration]]
- [[#questions][Questions]]
  - [[#why-source-run_libsh-instead-of-just-executing-it][Why source ~./run_lib.sh~ instead of just executing it?]]
  - [[#whats-with-run-not-having-an-sh-extension-and-why-is-run_libsh-not-executable][What's with ~./run~ not having an ~sh~ extension? And why is ~./run_lib.sh~ not executable?]]
  - [[#why-is-there-more-blather-in-this-file-than-in-any-other-file-in-this-repo][Why is there more blather in this file than in any other file in this repo?]]

* Description

Have you ever used ~make~ just as a command runner? In just the last year I've
worked on projects that require commands to be run using Gradle, NPM, Yarn,
straight bash scripts, random Python and pip, Terraform, Docker and
docker-compose, aws, Svelte, and Rust. How exciting, but also what a lot of context
switching. How do I build and deploy this Java project again? How do I run the
Svelte dev server? What's the gradle command to build jOOQ POJOs for a particular sub-module? So
boring. I want to write these things down, as succinctly as possible, and be
able to glance at a file or script output and see what's available to me for
this particular project.

~make~ offers a ubuiquitous and simple way to create this kind of project menu for
developers. It's also using a classic tool to solve a more modern problem, and
therefore cool. You can add targets to print out help, or use something like
[[https://github.com/tj/mmake][modern make]].

What're the down-sides to using ~make~ in this way?
  - It's crap. Whoops, I mean it doesn't work if you indent with spaces instead
    of tabs.
  - No built-in support for help, so you have to use boiler plate. And the
    default action for ~make~ is to compile code and if you override that and
    make the default a display of help suggestions then some grease-bag
    somewhere will smell what you've done, look up from their C and come zooming
    over on the Segway to scold you.
  - It's designed for things that _make_ files, with dependencies, and not just
    for running random commands. This creates a cognitive barrier for those who
    just want to run stuff, and it irritates the hell out of those who do
    actually use make for building stuff. And the work-around, adding ~.PHONY:~ everywhere is straight-up embarassing.
  - Every line in a target executes as a new shell. Good luck trying to anything
    complicated and multi-line, e.g. sourcing something useful.

What about ~npm~ and adding to ~scripts~ in ~packages.json~? Only if you want
data scientists and back-end developers to hate you.

Why not just use scripts?
  - It feels heavy to create a script for one or two commands, and foresee many
    others breeding like rabbits in the root of your project. Think of the
    whining from your colleagues who just use IDEs.
  - The root dir of a project will contains lots of other files, and scripts get
    lost. Doing ~ls *.sh~ is simply not good enough. I suppose you could create
    a ~scripts~ dir, but we're just talking about, essentially, handy shortcuts
    here, not serious project code. So this is also also a bit heavy.
  - ~make~ will use ~sh~, unless you tell it not to with more boiler-plate.

So why use this script?
  - Because it's simple, unambiguous, easy to read and use, and probably good
    enough. If any of this can be done better then please come forward and educate me. NB nerds: better != more succintly. I've chosen some verbosity for the sake of comprehensibility.
  - It's written in bash, which is ideal if you want to write bash to do stuff.
  - It does away with the problems of using Makefiles for this purpose, and
    replaces it with as yet unknown problems! If you see any PR me or mail me and we'll see what can be done.

* Features
  - Provides an easy way create a project menu around whatever bash you already
    want to write.
  - Has a README that is way longer than the actual code.

* Installation
~run_lib.sh~ is just a bash script so there are many ways to skin this cat.
Here's what I recommend. Note this assumes you store things you run in
~~/bin/~. If you don't want it there then change the code in this section.

Get the repo:
#+BEGIN_SRC bash
git clone TODO ~/bin/run_lib
#+END_SRC

Add the following to your ~.<shell>rc~, so you can just run ~run_lib~ to put the
scripts in your project, where ever you are. The name of this alias will be the hardest thing to
remember, but hopefully it won't vanish along with all the other aliases you've
created over the years.
#+BEGIN_SRC bash
run_lib() {
  cp --interactive ~/bin/run_lib/run_lib.sh .
  cp --interactive ~/bin/run_lib/run .
}
#+END_SRC

You could just ~wget~ the files from GitHub and avoid having to clone the repo.
But then I, or some other malicious actor, could change the file and when run it
might do damage. So don't do that.

* Configuration
Configuration means adding your functions to ~./run~, like this:
#+BEGIN_SRC bash
# Let the world know the truth
linux_is_better_than_osx (){
  echo -e "Linux for ever"
}
#+END_SRC

Notice the single-line comment, to be used when you execute ~./run~ without any arguments.

Make sure sourcing ~run_lib.sh~ is the last thing you do.

* Questions
** Why source ~./run_lib.sh~ instead of just executing it?
Sourcing means everything in ~run_lib.sh~ is introduced as part of your current shell, and not in a new
   one. If you executed it, i.e. ~./run_lib.sh "$@"~ instead of
   ~source ./run_lib.sh "@$"~, then it'd be a new shell and none of the colours
   would work and the code that looks for functions would be looking at
   ~./run_lib.sh~ instead of ~./run~. It'd straight-up not work.
** What's with ~./run~ not having an ~sh~ extension? And why is ~./run_lib.sh~ not executable?
   May I refer you to [[https://google.github.io/styleguide/shellguide.html#s2.1-file-extensions][Google's style guide]]?
** Why is there more blather in this file than in any other file in this repo?
   Because some things are worth explaining, or even if they're not they're fun
   to explain, also I don't care what you think.
